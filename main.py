import schemas
from fastapi import FastAPI, HTTPException, Depends, status, UploadFile, File
from fastapi.security import HTTPBasic, HTTPBasicCredentials
from fastapi.middleware.cors import CORSMiddleware
from typing import List
from pydantic import BaseModel
from sqlmodel import Session, select, create_engine, SQLModel
from dotenv import load_dotenv
from datetime import datetime
import os

load_dotenv()

app = FastAPI(title="File Upload API", version="1.0.0")

# Enable CORS for frontend communication
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

security = HTTPBasic()

# --- Authenticaton layer for user ---
def verify_credentials(credentials: HTTPBasicCredentials = Depends(security)):
    correct_username = os.getenv("ADMIN_USER")
    correct_password = os.getenv("ADMIN_PASSWORD")
    if credentials.username != correct_username or credentials.password != correct_password:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Basic"},
        )
    return credentials.username

# ---- Database connection initial setup ----
sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"
engine = create_engine(sqlite_url)


# This runs when the app starts: It checks if tables exist, and creates them if not
def create_db_and_tables():
    SQLModel.metadata.create_all(engine)

# We run this immediately
create_db_and_tables()





@app.get("/")
def read_root():
    return "Welcome to my Project where the FastAPI backend is  configured to reload upon codechanges with uvicorn"







# --- THE ENDPOINT for collecting data from the user most likely will be an upload option for send a file over TCP ---
@app.post("/upload")
def upload_data(file: UploadFile = File(...), username: str = Depends(verify_credentials)):
    # 1. Extract file info
    file_name = file.filename
    file_size = file.size if file.size else 0
    file_type = file.content_type

    # 2. Apply Rules (Logic)
    status = ""
    reason = ""
    MAX_FILE_SIZE = 10 * 1024 * 1024  # 10 MB

    if file_size > MAX_FILE_SIZE:
        status = "Rejected"
        reason = "File size exceeds 10MB limit. Please reduce the file size."
    elif file_type and "pdf" not in file_type.lower():
        status = "Invalid Format"
        reason = "Only PDF files are accepted."
    elif not file_name:
        status = "Rejected"
        reason = "File name is required."
    else:
        status = "Accepted"
        reason = "File successfully received by the system."

    # 3. SAVE TO DATABASE (The Magic Part) ðŸ’¾
    file_record = schemas.FileUpload(
        name=file_name,
        file_type=file_type or "unknown",
        size=file_size,
        status=status,
        reason=reason
    )
    
    with Session(engine) as session:
        session.add(file_record)  # Prepare to save
        session.commit()  # Save changes to the database
        session.refresh(file_record)  # Get the new ID generated by the DB

    return {
        "status": status,
        "reason": reason,
        "database_id": file_record.id,
        "file_name": file_name,
        "uploaded_by": username
    }






# --An endpoint to display all the files in our database with security for access control  --
@app.get("/dashboard")
def view_dashboard(username: str = Depends(verify_credentials)):
    with Session(engine) as session:
        statement = select(schemas.FileUpload)
        results = session.exec(statement).all()
        return {
            "retrieved_by": username,
            "total_files": len(results),
            "files": results
        }

	



@app.delete("/files/{file_id}")
def delete_file(file_id: int, username: str = Depends(verify_credentials)):
    with Session(engine) as session:
        # 1. Find the file by ID
        file = session.get(schemas.FileUpload, file_id)

        # 2. If the file does not exist then stop right there
        if not file:
            raise HTTPException(status_code=404, detail="File not found")

        # 3. Delete it
        session.delete(file)
        session.commit()

        return {"ok": True, "message": f"File {file_id} has been deleted by {username}."}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
