import schemas
from fastapi import FastAPI, HTTPException, Depends, status
from fastapi.security import HTTPBasic, HTTPBasicCredentials
from typing import List
from pydantic import BaseModel
from sqlmodel import Session, select, create_engine, SQLModel
from dotenv import load_dotenv
import os

load_dotenv()

app = FastAPI()

security = HTTPBasic()

# --- Authenticaton layer for user ---
def verify_credentials(credentials: HTTPBasicCredentials = Depends(security)):
    correct_username = os.getenv("ADMIN_USER")
    correct_password = os.getenv("ADMIN_PASSWORD")
    if credentials.username != correct_username or credentials.password != correct_password:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Basic"},
        )
    return credentials.username

# ---- Database connection initial setup ----
sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"
engine = create_engine(sqlite_url)


# This runs when the app starts: It checks if tables exist, and creates them if not
def create_db_and_tables():
    SQLModel.metadata.create_all(engine)

# We run this immediately
create_db_and_tables()





@app.get("/")
def read_root():
    return "Welcome to my Project where the FastAPI backend is  configured to reload upon codechanges with uvicorn"







# --- THE ENDPOINT for collecting data from the user most likely will be an upload option for send a file over TCP ---
@app.post("/upload")
def upload_data(input_file: pdf):
    
    file = input_file

    # 2. Apply Rules (Logic)
    status = ""
    reason = ""

    if file.size:
        status = "Rejected"
        reason = "Space is  not available reduce the file size."
    elif file.type != pdf:
        status = "Invalid Format"
        reason = "Added to data_lake  pool."
    elif "name" not in file:
        status = "Rejected"
        reason = "Name is required."
    else:
        status = "Accepted"
        reason = "Welcome to the Machine Learning Algo"

    # 3. SAVE TO DATABASE (The Magic Part) ðŸ’¾
    # We open a "Session" (a temporary connection) to the DB
    with Session(engine) as session:
        session.add(file)  # Prepare to save
        session.commit()        # Save changes to the file
        session.refresh(file) # Get the new ID generated by the DB

    return {
        "status": status,
        "reason": reason,
        "database_id": data
    }






# --An endpoint to diplay all the files in our database we can add security here in the future for acce4ss control  --
@app.get("/dashboard")
def view_dashboard(depends = verify_credentials):

    with Session(engine) as session:
        statement = select(file)
        results = session.exec(statement).all()
        return results

	



@app.delete("/files/{file_id}")
def delete_candidate(candidate_id: int, username: str = Depends(verify_credentials)):
    with Session(engine) as session:

        # 1. Find the file by ID
        file = session.get(file, file_id)

        # 2. If the file  does not  exist then  stop right there
        if not file:
            return {"error": "file not found"}

        # 3. Delete them
        session.delete(file)
        session.commit()

        return {"ok": True, "message": f"File {file_id} has been deleted by {username}."}
                                                   






if __name__ == "__main__":
    main()
